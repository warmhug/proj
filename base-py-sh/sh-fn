#!/bin/bash

check_chinese() {}

# è·å–å½“å‰è·¯å¾„å’Œçˆ¶è·¯å¾„
# echo "$(dirname $(/bin/pwd))"
# echo "$(basename $(/bin/pwd))"
current_path=$(/bin/pwd)
get_parent_dir() {
  local current_dir=$(basename "$current_path")
  local parent_dir="${current_path%$current_dir}"
  echo $parent_dir
}
parent_dir=$(get_parent_dir)

command_exists () {
  command -v "$1" >/dev/null 2>&1
}

# è·¨å¹³å°
check_install() {
  local target="${1:-"ldconfig"}"
  if command -v $target >/dev/null 2>&1; then
    echo "[OK] $target is available: $(command -v $target)"
  else
    echo "[WARN] $target is not available."
    # Detect package manager
    if command -v apt-get >/dev/null 2>&1; then
      echo "You can install it via: apt-get update && apt-get install -y libc-bin"
    elif command -v yum >/dev/null 2>&1; then
      echo "You can install it via: yum install -y glibc"
    elif command -v dnf >/dev/null 2>&1; then
      echo "You can install it via: dnf install -y glibc"
    elif command -v apk >/dev/null 2>&1; then
      echo "You can install it via: apk add libc-utils"
    else
      echo "No known package manager detected. Please install $target manually."
    fi
  fi
}

usage() {
  if [ $# -eq 0 ]; then
    echo "Usage: $0 xx"
    return 1
  fi
}

# è¯»å–ç”¨æˆ·è¾“å…¥
confirm_action() {
  local prompt_message="$1"
  local user_input

  read -p "$prompt_message (y/n): " user_input
  user_input=${user_input:-y}  # é»˜è®¤å€¼ä¸º 'y'ï¼Œå¦‚æœç”¨æˆ·ç›´æ¥æŒ‰å›è½¦

  if [[ $user_input =~ ^[Yy]$ ]]; then
    return 0  # è¡¨ç¤ºç¡®è®¤ï¼Œè¿”å›æˆåŠŸçŠ¶æ€
  else
    return 1  # è¡¨ç¤ºå–æ¶ˆï¼Œè¿”å›å¤±è´¥çŠ¶æ€
  fi
}

datef() {
  local fmt="${1:-"%Y_%m_%d-%H_%M_%S"}"
  local output=$(date "+$fmt")
  echo "[$output]"
  # date "+$fmt"
}
# datef "%Y-%m-%d"

add_blank_lines() {
  # return 1
  # echo -e "\n" >> $sync_log
  printf '\n%.0s' {1..5} >> $sync_log
}

get_special_files() {
  special_files=(".pnpmfile.cjs" ".npmrc" "pnpm-lock.yaml" ".git")
  # 2024-08 bash æŸ¥æ‰¾ packages ç›®å½•ä¸‹äºŒçº§ ç›®å½•é‡Œå­˜åœ¨çš„æ‰€æœ‰ config.ts congfig.tsx config.js å’Œ config ç›®å½•ï¼Œæ’é™¤æ‰ node_modules ç›®å½•ã€‚ä¸æŸ¥æ‰¾å­è·¯å¾„ã€‚æŸ¥æ‰¾ç»“æœ å­˜æ”¾åˆ°æ•°ç»„é‡Œã€‚
  # special_files+=($(find packages/*/src -maxdepth 1 -type f \( -name "config.ts" -o -name "config.tsx" -o -name "config.js" \) -not -path "*/node_modules/*" -o -type d -name "config" -not -path "*/node_modules/*"))
  # for item in "${special_files[@]}"; do echo "$item"; done
}
# get_special_files

base64() {
  input_string="your string to encode"
  encoded_string=$(echo -n "$input_string" | base64)
  decoded_string=$(echo -n "$encoded_string" | base64 --decode)
}

check_chinese() {
  # ä½¿ç”¨ Node.js æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
  if node -e "let s = process.argv[1]; process.exit(s.match(/[\u4e00-\u9fa5]/) ? 0 : 1)" "$string"; then
    echo "å­—ç¬¦ä¸²åŒ…å«ä¸­æ–‡å­—ç¬¦ã€‚"
  else
    echo "å­—ç¬¦ä¸²ä¸åŒ…å«ä¸­æ–‡å­—ç¬¦ã€‚"
  fi

  # è¯†åˆ«å­—ç¬¦ä¸²åŒ…å«çš„ä¸­æ–‡
  string="Helloï¼Œä¸–ç•Œï¼"
  # string="Hello"
  # ä½¿ç”¨ printf å°†æ¯ä¸ªå­—ç¬¦è½¬æ¢ä¸º Unicode ç¼–ç 
  for ((i=0; i<${#string}; i++)); do
    char="${string:i:1}"
    unicode=$(printf "%04X" "'$char")
    echo "å­—ç¬¦: $char, Unicode ç¼–ç : \\u$unicode"
  done
  # ä½¿ç”¨ bash è¯­å¥, åœ¨ macOS é‡Œä¸æ­£å¸¸
  if [[ $string =~ [\u4e00-\u9fa5] ]]; then
    echo "å­—ç¬¦ä¸²åŒ…å«ä¸­æ–‡"
  else
    echo "å­—ç¬¦ä¸²ä¸åŒ…å«ä¸­æ–‡"
  fi
}


# git

git_tags() {
  # å…ˆ git tag -l > tags.txt
  # å†è¿è¡Œæœ¬è„šæœ¬
  while read -r line; do
    git tag -d "$line"
    # git push origin --delete "$line"
  done < tags.txt
}

# è·å– git log çš„ ç¬¬ä¸€æ¡ æœ€åä¸€æ¡ æ€»æ•° ç­‰ä¿¡æ¯ï¼Œæ”¾åˆ° bash æ•°ç»„é‡Œ
git_log() {
  # current_branch
  branch_name=$(git symbolic-ref --short HEAD)
  all_commits_num=$(git rev-list --count HEAD)
  all_commits=$(git log $branch_name --format=%H:%an:%s)
  latest_commit=$(git log $branch_name -1 --pretty=%H)
  skip_latest_commit=$(git log --skip=1 --pretty=%H)
  first_commit=$(git log $branch_name --reverse --skip=1 $latest_commit --pretty=%H | head -n 1)
  first_commit=$(git rev-list --max-parents=0 HEAD)
  echo $latest_commit
  echo $first_commit

  declare -a commits_info

  # ä½¿ç”¨ while å¾ªç¯è¯»å– git log è¾“å‡ºï¼Œå¹¶å°†ä¿¡æ¯è¿½åŠ åˆ°æ•°ç»„ä¸­
  while IFS= read -r line; do
    commits_info+=("$line")
  done < <(echo "$all_commits")

  echo "commits count: "${#commits_info[@]}

  for info in "${commits_info[@]}"; do
    if [[ "$info" != "$first_commit" ]]; then
      echo "$info"
      # echo "${info%%:*}, ${info#*:}"
      # do sth
      # git cherry-pick $info
    else
      echo first_commit: "$first_commit"
    fi
  done
}

# å¤‡ä»½åˆ†æ”¯
git_branch_backup() {
  if [ -z "$1" ]; then
    echo "è¯·è¾“å…¥è¦å¤‡ä»½çš„åˆ†æ”¯å"
    return 1
  fi
  local bk_branch_name=backup-$1
  local branch_exists=$(git branch | grep "$bk_branch_name")
  if [ -n "$branch_exists" ]; then
    echo -e "
    å¤‡ä»½åˆ†æ”¯å $bk_branch_name å·²å­˜åœ¨ è¯·è¿è¡Œå‘½ä»¤åˆ é™¤æˆ–æ”¹å
      git branch -D $bk_branch_name
    "
    return 1
  else
    # åšå¤‡ä»½
    git checkout -b "${bk_branch_name}"
  fi
}

# å‹ç¼©åˆ†æ”¯çš„æäº¤  ä½¿ç”¨ /bin/zsh æ‰§è¡Œï¼Œä¸ç„¶æ˜¾ç¤ºæœ‰é—®é¢˜
git_commits_squash() {
  local feature_branch="$1"
  local base_branch="$2"
  if [ -z "$1" ]; then
    local feature_branch=$(git symbolic-ref --short HEAD)
  fi
  if [ -z "$2" ]; then
    local base_branch="origin/master"
  fi
  # echo "å‚æ•° $1 $2 , $feature_branch $base_branch"

  local gitStatus=$(git status --porcelain)
  if [ "$gitStatus" != "" ]; then
    echo "Your git status is not clean"
    return 1
  fi

  git_branch_backup $feature_branch || return 1
  git pull

  echo "\033[32m
  åˆå¹¶ ${feature_branch} æˆä¸€ä¸ª commitï¼Œå¹¶å½’é›†æ‰€æœ‰å¾…åˆå¹¶ commit çš„ messages
  \033[0m"
  git checkout "${feature_branch}"

  calc_commits_num $base_branch $feature_branch
  local commits_num=$calc_commits_num_result
  echo $commits_num

  # å¦‚æœåªæœ‰ä¸€ä¸ª commitï¼Œåˆ™æ— éœ€åˆå¹¶
  if [ $commits_num -lt 2 ]; then
    echo "\033[32m
    åªæœ‰ä¸€ä¸ªæäº¤ï¼Œä¸éœ€è¦å‹ç¼©
    \033[0m"
    return 0
  fi

  # æ”¶é›†æ‰€æœ‰å¾…åˆå¹¶ commits çš„ message
  local commits_message=""
  for ((i = commits_num - 1 ; i >= 0 ; i--)); do
    # MESSAGE=$(git log --format=%s HEAD~${i} -1)
    MESSAGE=$(git log --format='%h - %an - %ad %n %s' HEAD~${i} -1)
    commits_message+="${MESSAGE}
  "
  done
  local new_message="ğŸ“¦ chore: Squashed ${commits_num} commits:

  ${commits_message}"

  echo -e "\033[32m è¯·ç¡®è®¤æ˜¯å¦åˆå¹¶è¿™äº›commits (y/n) : \033[0m"
  printf $new_message

  read answer
  [[ $answer = "n" ]] && return 1

  # æ¢å¤åˆ° base åˆ†æ”¯çš„ æœ€åä¸€æ¬¡æäº¤
  git reset --soft $(git rev-parse HEAD~$commits_num)
  git add --all
  git commit -am "${new_message}"

  echo "
  å»ºè®®å†æ‰‹åŠ¨è¿è¡Œ git commit --amend é¢å¤–æ·»åŠ  commit æ³¨é‡Š
  æäº¤ git push --force-with-lease
  "
  # git log
  # git push origin "${feature_branch}" --force-with-lease
}

gitignore_get() {
  gitignore=()
  GITIGNORE_FILE=".gitignore"
  if [ ! -f "$GITIGNORE_FILE" ]; then
    echo ".gitignore file not found in the current directory!"
    exit 1
  fi
  while IFS= read -r line; do
    # ç§»é™¤è¡Œé¦–å°¾çš„ç©ºç™½å­—ç¬¦
    stripped_line=$(echo "$line" | tr -d '[:space:]')
    # è·³è¿‡ç©ºè¡Œå’Œä»¥ '#' å¼€å¤´çš„æ³¨é‡Šè¡Œ
    if [ -n "$stripped_line" ] && [ "${stripped_line:0:1}" != "#" ]; then
      # echo "$stripped_line"
      gitignore+=("--exclude=$line")
    fi
  done < "$GITIGNORE_FILE"
  # echo "${gitignore[@]}"
  for item in "${gitignore[@]}"; do echo "$item"; done
  # diff çš„ exclude å‚æ•° ä¸è®¤è¯† .gitignore æ–‡ä»¶é‡Œçš„ **/**/es/** è¿™ç§å†™æ³•
  # diff -rq --exclude=.git --exclude=**/**/es/** . /tmp/pro-components > diff.txt
}


# 2016 è‡ªåŠ¨ commit push
function commit() {
  # printf "\n"
  echo "\033[32m git op (y/n)?  \033[0m"
  read git_op
  [[ $git_op = "n" ]] && exit
  BASEDIR=$(dirname $0)
  ## echo $BASEDIR
  cd $BASEDIR
  echo "\033[32m git status \033[0m"
  git status
  read -p "Press Return to Close..."
}
