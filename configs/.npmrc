
# https://docs.npmjs.com/cli/v10/using-npm/config
# https://docs.npmjs.com/cli/v10/configuring-npm/package-json
# https://docs.npmjs.com/cli/v9/using-npm/config
# http://yarnpkg.com

# https://jpospisil.com/2017/06/02/understanding-lock-files-in-npm-5

# package.json 里设置 `"packageManager": "pnpm@7.33.7"` 会使得 在当前目录运行 pnpm -v 始终是 7.33.7 而忽略系统安装的 不同 pnpm 版本.
# 原因是 https://github.com/nodejs/corepack


# https://www.npmjs.com/package/@types/react-dom/v/18.3.1?activeTab=code
# 比如 @types/react-dom 18 的 "dependencies": { "@types/react": "*" } 版本号是 *
# 在 monorepo 中 存在 @types/react 16 17 18 多个版本, pnpm 使用 最低版本 16.
# 而除了 "古老" 的包外 其他包实际需要的是 @types/react 18 版本, 使用 pnpm overrides 功能统一覆盖解决.


ignore-scripts=true
legacy-peer-deps=true
omit-lockfile-registry-resolved=true  # npm 特有


#
# configs for npm/pnpm/yarn
#
# node-options=--max_old_space_size=8192
; loglevel=verbose
package-lock=false
update-notifier=false
engine-strict=true  # 对 package.json 里的 "engines": { "node": ">=18" } 起作用

registry=https://registry.npmmirror.com



#
# pnpm 特有配置
#
# 注意: 从 pnpm/CHANGELOG 里查看 API 的变更.
# http://pnpm.io
# https://github.com/pnpm/pnpm/blob/main/pnpm/CHANGELOG.md
#
# 注意: pnpm v7 文档 不全, 有些在 version-4.x 里
# https://github.com/pnpm/pnpm.io/blob/v7/docs/npmrc.md
# https://github.com/pnpm/pnpm.io/blob/v7/versioned_docs_archived/version-4.x/npmrc.md
#
#
# https://pnpm.io/symlinked-node-modules-structure
# 分析 /node_modules/.modules.yaml 文件
# pnpm(v7+) 的 Isolated 即通过 node-linker=hoisted 设置
# 每个子包的 node_modules 只存自己依赖的软链接  没有 hoist 到顶层
#
#
# 场景:
# 当同一个包 pkga@1.1.1 "分别"发到不同的 registry a/b/c 时, 会生成不同的 integrity a/b/c.
# 先在 registry a 下, 进行 pnpm install 会缓存 pkga@1.1.1 在 pnpm store path 目录下, 并生成 pnpm-lock.yaml 文件. 此时 拷贝 此 lock 文件到 registry b 下. lock 文件中 pkga@1.1.1 仍是 integrity-a (实际应该修改为 integrity-b ) 但 pnpm install 仍能成功, 为什么? 因为 直接读了 pnpm store path 目录下的 pkga 的缓存.
# 注意: 但在 服务器上, a/b 属于不同容器, b 读不了 a 的缓存, b 在安装时候 就会报错.
# 在本地电脑 这个错误被 "隐藏" 了! 在 registry b 里 先运行 rm -rf "$(pnpm store path)" 再 pnpm install --frozen-lockfile 即可复现.
verify-store-integrity=false  # 7.7.0 开始默认 false. npm 没有相匹配的配置
verify-deps-before-run=install

# https://pnpm.io/workspaces monorepo 场景:
# 比如 package.json 文件的 "dependencies": { "demo0": "npm:demo1@^2.0.1", "demo": "workspace:demo2@*" }
# 这类 npm alias 依赖. 内部存在 demo2 这个包, 但 pnpm ls demo2 无结果, 而 pnpm ls demo 有结果.
link-workspace-packages=deep
workspace-concurrency=1  # default: Infinity

#
# https://github.com/facebook/docusaurus/blob/main/packages/docusaurus-module-type-aliases/package.json
# https://github.com/facebook/docusaurus/blob/main/packages/docusaurus-types/package.json
# 注意如上 @docusaurus/module-type-aliases 和 @docusaurus/types 里 package.json 的 "@types/react": "*" 这种 * 的写法, 会依赖 monorepo 根目录的 @types/react 版本.
# 场景: 在 pnpm 下, 因为 不同子包 依赖的 @types/react 大版本不一致, 不能在 根目录下 设置统一的 @types/react 版本. 子包 a/b/c 依赖了 @types/react@16^ 子包 d/e/f 及其下层依赖 因为声明了 @types/react: * 就也实际使用了 @types/react@16^ 版本, 但他们实际需要的是 @types/react@18^ 版本, 这样导致错误.
# 通过 pnpm why -r @types/react 查看实际使用版本.
# public-hoist-pattern[]=@types*  # 当能对所有子包 types 统一版本时, 提升依赖
# public-hoist-pattern[]=!@types/react
# hoist-pattern[]=*
# hoist-pattern[]=!@types/react-dom
# hoist-pattern[]=!@types/react

#
#
auto-install-peers=false
strict-peer-dependencies=false  # pnpm@7 默认是 true

# enable-pre-post-scripts=true
# package-manager-strict=true  # since v9 默认 true , v10 packageManagerStrict
# resolution-mode=lowest-direct
#
#
#
lockfile=false
# lockfile-include-tarball-url=false  # 实际不起作用
recursive-install=false
reporter=append-only
pnpmfile=node_modules/.pnpm-config/@pnpm/types-fixer/pnpmfile.cjs
