# cpp

- [C++基础入门](http://study.163.com/course/courseMain.htm?courseId=1002981021): 1.学习纲要
- [《面向对象程序设计-C++》](http://study.163.com/course/courseMain.htm?courseId=271005): 
  - 1.第一个C++程序。如何使用 Eclipse 编写 cpp 
  - 5.头文件。头文件里不该写什么？介绍编译过程
  - 8.成员变量的秘密。介绍 this 指针是什么（类似 js 的this/prototype）
  - 11.new & delete。动态内存申请和销毁，内存泄露
  - 13.初始化列表。Initialization 初始化，类成员的特殊初始化方式
  - 18~41 其他基础内容详解

## 基础

- 模板
  - 模板也能像函数一样可以重载。
  - 显式具体化(explicit specialization)、显式实例化(explicit instantiation)、隐式实例化统称为具体化，在同一个文件中使用同一种类型的显式实例和显式具体化将出错。
  - 类模板可以被部分具体化，其他同函数模板一样可以 隐式实例化、显式实例化、显式具体化。
  - 模板类可用作其他类、结构和模板的成员。

- 类和对象
  - 公有继承能够建立 is-a 关系，私有继承和保护继承建立的是 has-a 关系，他们都能重用基类的代码。
  - 无论哪种继承，都继承实现，并不继承接口。在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。
  - 通常，应使用包含（组合、mixin）来建立 has-a 关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。
  - 多重继承（MI）使得能够在类设计中重用多个类的代码，私有或保护 MI 建立 has-a 关系，而共有 MI 建立 is-a 关系。
  - MI 会带来一些问题，使用类限定符来解决名称二义性的问题，使用虚基类来避免继承多个基类对象的问题。
  - 友元类：比如电视机和遥控器互相不是 is-a 或 has-a 关系，但遥控器能改变电视机状态，应将遥控器类作为电视机类的友元。
  - 友元使得能够为类开发更灵活的接口，类可以将其他函数、其他类和其他类的成员函数作为友元。
  - 嵌套类是在其他类中声明的类，能实现其他类，但不必是公有接口的组成部分。

- 函数
  - ANSI C 借鉴了 C++ 中的函数原型，但为了和 C 兼容、原型是可选的，但在 C++ 中，原型是必不可少的。
  - 函数原型能帮编译器正确处理函数返回值，检查使用的参数数目、参数类型是否正确。
  - C++ 通常按值传递参数。即传递常规变量的拷贝、或数组地址的拷贝。一般需要禁止无意修改数组内容，在函数数组形参前使用 const 可以保证。
  - 将指针参数 声明为 指向 const 的指针：使用 const 使得函数能够处理 const 和非 const 实参
  - 函数参数为 结构体 时，可以为小的结构体的拷贝，也可以为结构体的地址
  - 对于 inline 内联函数，部分编译器如果认为该函数过大或该函数调用了自己(递归),就不将其作为内联函数
  - 引用 & 经常被用作函数参数，称为 按引用传递，能允许被调用的函数能够访问调用函数中的变量（C 语言只能按值传递或按指针传递），应尽可能将引用形参声明为 const
  - C++11 提供了函数指针和函数符的替代品--lambda 表达式

- 指针和引用的区别
  - 引用总是指向某个对象，定义引用时必须初始化(之后不可改变)；引用只是一个“别名”，给引用赋值修改的是引用所关联对象的值
  - 指针可以指向任何对象，可以修改。
  - 不能对未被初始化为适当地址的指针解除引用。

- new 出来的对象，需要手动 delete，然后再设置为 NULL
  - 只能用 delete 来释放使用 new 分配的内存；不能用 delete 来释放普通变量声明所获得的内存。
  - 手工管理内存，非常容易出错，导致“内存泄露”问题，排查非常困难。使用智能指针，避免这种问题。
  - 当使用 delete 时，类的析构函数会被自动调用。删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存，因此要在析构函数使用 delete 删除对象成员的内存。

- 内存模型
  - 自动变量：函数内的变量(包含函数参数)；静态变量：函数外的变量、使用 static 定义的变量；动态变量：new 出来的变量。
  - 自动变量保存在栈（LIFO 后进先出）中、变量数量可以灵活增减；静态变量数目在程序运行期间不会变，因此不需要栈来管理，编译器将分配固定的内存块来存储所有的静态变量，这些变量在程序执行期间一直存在。
  - 位于函数内的变量是「局部变量(自动变量)」，位于函数外的变量是「全局变量」，全局变量对所有的程序文件都是可见的。
  - 使用 static 修饰局部变量、可以在函数调用之间保持局部变量的值、不需要在每次进入和离开函数时进行创建和销毁。
  - 使用 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
  - extern 是用来在另一个文件中声明一个全局变量或函数，用于当有两个或多个文件共享相同的全局变量或函数时。
  - 在函数或代码块中声明 const 时，其作用域为代码块，所以不用担心与外部的 const 常量重名引起冲突。
  - C/C++ 都不允许在一个函数中定义另外一个函数，因此所有函数都是静态存储，在整个程序执行期间一直存在。
  - 可以使用 static 定义静态函数，使函数只在文件内可见，这样可以在其他文件中定义同名的函数。
  - 使用 C++ 运算符 new（或 C 函数 malloc()）分配的内存称为动态内存，不受作用域限制，可以在一个函数中分配内存，在另一个函数中释放。动态内存不是 LIFO。
  - 通常编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，另一块用于动态存储。

- 异常
  - 对于不同的异常类型，基类引用能够捕获各派生类异常对象，而派生类异常只能捕获从这个类派生而来的类对象。
  - 使用异常会降低程序的运行速度。

- 头文件：
  - 可包含：函数原型，使用 #define 或 const 定义的常量，结构/类/模板声明，内联函数。
  - 不能包含：函数定义/函数体、变量声明。不要使用 using 指令。

- 命名空间
  - 命名空间可以是全局的，也可以位于另一个命名空间中，但不能位于代码块中。
  - using 声明：`using std::cout`，using 编译指令：`using namespace std`，首选在局部作用域内使用 using 声明。
  - 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量或静态全局变量。

何时使用引用参数：
![何时使用引用参数](https://zos.alipayobjects.com/rmsportal/CpddxowZkhtkSoOVasEN.jpg)

如何选择智能指针：要使用多个指向同一个对象的指针，应选择 shared_ptr；反之使用 unique_ptr。

RTTI 只适用于包含虚函数的类。有三个运算符：dynamic_cast 、Typeid 。

不同的编译器对同一个函数生成不同的修饰名称，名称不同将使链接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有对象文件或库都是由同一个编译器生成的。通常可以用自己的编译器重新编译源代码来消除链接错误。

C 和 C++ 使用 & 符号来指示变量的地址，C++ 也用 & 符号来声明引用。

通常使用 vector 是最好的选择，除非你有很好的理由选择其他容器。

数组是一种数据结构，在内存中连续存储同类型的多个值。C++ 将数组名解释为其第一个元素的地址：arr == &arr[0]

浮点数能够表示小数值、非常大和非常小的值（比整型范围大），但浮点数运算速度比整数慢、且精度将下降。

如何选择数据类型？通常来说 int 被设置为对目标计算机来说最“自然”(处理起来效率最高)的长度，如果没有特殊理由，则应使用 int。
如果变量表示的值不可能为负数，如人口数、文档字数，则可以使用无符号类型，这样能够表示更大的值。
如果可能超过 int 类型的最大值，则使用 long 或 long long，便于程序移植到低位数的系统上而不出现问题。
如果节省内存很重要，则应使用 short 而不是 int，即使它们的长度一样。例如 int 数组从 16 位系统移到 32 位系统，内存占用会加倍。

cin 和 cout 都是智能对象，能根据程序上下文自动“转换类型”。例如 C 语言要打印字符串"25"和整数 25 ，需要这样：
`printf("print a string: %s\n", "25");`、`printf("print an integer: %d\n", 25);`，而 cout 能自动转换。

类之于对象 就像 类型之于变量。面向对象编程（OOP）的本质是设计并扩展自己的数据类型。

编译指令 using [namespace] 可以位于任何位置，如果在函数中、只会在本函数作用域里有效。
也可以完全不使用编译指令 using，而在需要时、直接加上命名空间前缀即可、如 `std:cout << "out sth" << std:endl;`

预处理指令 #include 来引用头文件，引用头文件相当于复制头文件的内容。
建议把所有的常量、宏、系统全局变量和函数原型写在头文件中。

C++ 可以使用 C 的头文件，C++ 头文件去掉了扩展名 h，有些 C 头文件被转换为 C++ 头文件时被重新命名，
去掉了扩展名 h，并在文件名称前面加上前缀 c (表明来自 c 语言)，例如 C++ 版本的 math.h 为 cmath。

---

## 泛型编程

[泛型编程、STL](http://www.cnblogs.com/youngforever/p/3251097.html)

模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。迭代器是广义指针。

最好避免直接使用迭代器，而应尽可能使用 STL 函数（如 for_each()）来处理细节，也可使用 C++11 新增的基于范围的 for 循环：
`for (auto x : scores) cout << x << endl;`

STL 提供了函数对象（函数符），函数对象是重载了()运算符（即定义了 operator()() 方法）的类。

泛型（generic）是一种允许一个值取不同数据类型（所谓多态）的技术，
强调使用这种技术的编程风格被称为泛型编程（generic programming通用编程/类属编程）。

STL（Standard Template Library 标准模板库）是泛型编程思想的实际体现和具体实现，
它是一种为泛型组件建立大型标准库的可扩展架构。STL本身，与面向对象无关，也与具体的程序设计语言无关。

STL 提供了一组表示容器、迭代器、函数对象和算法的模板。所有 STL 容器都提供了一些基本方法：size()、swap()、begin()、end()

STL 是泛型编程思想的产物。
STL 是最新的 C++ 标准函数库中的一个子集，这个庞大的子集占据了整个库的大约 80% 的分量。
而作为在实现 STL 过程中扮演关键角色的模板则充斥了几乎整个 C++ 标准函数库。

STL提供六大组件，彼此可以组合套用。
这六大组件的交互关系：
container（容器） 通过 allocator（配置器） 取得数据储存空间，
algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，
functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，
adapter（配接器） 可以修饰或套接 functor（仿函数）。

泛型编程是一种面向算法的多态技术，STL 是它的一种具体实现。

与针对问题和数据的面向对象的方法不同，泛型编程中强调的是算法。
是一类通用的参数化算法，它们对各种数据类型和各种数据结构都能以相同的方式进行工作，从而实现源代码级的软件重用。

例如，不管（容器）是数组、队列、链表、还是堆栈，不管里面的元素（类型）是字符、整数、浮点数、还是对象，
都可以使用同样的（迭代器）方法来遍历容器内的所有元素、获取指定元素的值、添加或删除元素，
从而实现排序、检索、复制、合并等各种操作和算法。

泛型编程的通用化算法，是建立在各种抽象化基础之上的：
利用参数化模版来达到数据类型的抽象化、利用容器和迭代器来达到数据结构的抽象化、
利用分配器和适配器来达到存储分配和界面接口的抽象化。

